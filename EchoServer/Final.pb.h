// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Final.proto

#ifndef PROTOBUF_INCLUDED_Final_2eproto
#define PROTOBUF_INCLUDED_Final_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Final_2eproto 

namespace protobuf_Final_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Final_2eproto
namespace Final {
class Account;
class AccountDefaultTypeInternal;
extern AccountDefaultTypeInternal _Account_default_instance_;
class Commands;
class CommandsDefaultTypeInternal;
extern CommandsDefaultTypeInternal _Commands_default_instance_;
class History;
class HistoryDefaultTypeInternal;
extern HistoryDefaultTypeInternal _History_default_instance_;
class Player;
class PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class Users;
class UsersDefaultTypeInternal;
extern UsersDefaultTypeInternal _Users_default_instance_;
}  // namespace Final
namespace google {
namespace protobuf {
template<> ::Final::Account* Arena::CreateMaybeMessage<::Final::Account>(Arena*);
template<> ::Final::Commands* Arena::CreateMaybeMessage<::Final::Commands>(Arena*);
template<> ::Final::History* Arena::CreateMaybeMessage<::Final::History>(Arena*);
template<> ::Final::Player* Arena::CreateMaybeMessage<::Final::Player>(Arena*);
template<> ::Final::Users* Arena::CreateMaybeMessage<::Final::Users>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Final {

// ===================================================================

class Account : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Final.Account) */ {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Account(Account&& from) noexcept
    : Account() {
    *this = ::std::move(from);
  }

  inline Account& operator=(Account&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Account* internal_default_instance() {
    return reinterpret_cast<const Account*>(
               &_Account_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Account* other);
  friend void swap(Account& a, Account& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Account* New() const final {
    return CreateMaybeMessage<Account>(NULL);
  }

  Account* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Account>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Account* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Final.History gameHist = 6;
  int gamehist_size() const;
  void clear_gamehist();
  static const int kGameHistFieldNumber = 6;
  ::Final::History* mutable_gamehist(int index);
  ::google::protobuf::RepeatedPtrField< ::Final::History >*
      mutable_gamehist();
  const ::Final::History& gamehist(int index) const;
  ::Final::History* add_gamehist();
  const ::google::protobuf::RepeatedPtrField< ::Final::History >&
      gamehist() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string password = 3;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // .Final.Player player = 5;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 5;
  private:
  const ::Final::Player& _internal_player() const;
  public:
  const ::Final::Player& player() const;
  ::Final::Player* release_player();
  ::Final::Player* mutable_player();
  void set_allocated_player(::Final::Player* player);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 wins = 7;
  void clear_wins();
  static const int kWinsFieldNumber = 7;
  ::google::protobuf::int32 wins() const;
  void set_wins(::google::protobuf::int32 value);

  // bool LoggedIn = 4;
  void clear_loggedin();
  static const int kLoggedInFieldNumber = 4;
  bool loggedin() const;
  void set_loggedin(bool value);

  // bool Challenged = 9;
  void clear_challenged();
  static const int kChallengedFieldNumber = 9;
  bool challenged() const;
  void set_challenged(bool value);

  // bool InGame = 10;
  void clear_ingame();
  static const int kInGameFieldNumber = 10;
  bool ingame() const;
  void set_ingame(bool value);

  // int32 loses = 8;
  void clear_loses();
  static const int kLosesFieldNumber = 8;
  ::google::protobuf::int32 loses() const;
  void set_loses(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Final.Account)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Final::History > gamehist_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::Final::Player* player_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 wins_;
  bool loggedin_;
  bool challenged_;
  bool ingame_;
  ::google::protobuf::int32 loses_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Final_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Commands : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Final.Commands) */ {
 public:
  Commands();
  virtual ~Commands();

  Commands(const Commands& from);

  inline Commands& operator=(const Commands& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Commands(Commands&& from) noexcept
    : Commands() {
    *this = ::std::move(from);
  }

  inline Commands& operator=(Commands&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Commands& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Commands* internal_default_instance() {
    return reinterpret_cast<const Commands*>(
               &_Commands_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Commands* other);
  friend void swap(Commands& a, Commands& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Commands* New() const final {
    return CreateMaybeMessage<Commands>(NULL);
  }

  Commands* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Commands>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Commands& from);
  void MergeFrom(const Commands& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Commands* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string command = 1;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  const ::std::string& command() const;
  void set_command(const ::std::string& value);
  #if LANG_CXX11
  void set_command(::std::string&& value);
  #endif
  void set_command(const char* value);
  void set_command(const char* value, size_t size);
  ::std::string* mutable_command();
  ::std::string* release_command();
  void set_allocated_command(::std::string* command);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string password = 3;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // string message = 4;
  void clear_message();
  static const int kMessageFieldNumber = 4;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:Final.Commands)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr command_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Final_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Player : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Final.Player) */ {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(Player&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Player& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Player* other);
  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Player* New() const final {
    return CreateMaybeMessage<Player>(NULL);
  }

  Player* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 units = 1;
  int units_size() const;
  void clear_units();
  static const int kUnitsFieldNumber = 1;
  ::google::protobuf::int32 units(int index) const;
  void set_units(int index, ::google::protobuf::int32 value);
  void add_units(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      units() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_units();

  // @@protoc_insertion_point(class_scope:Final.Player)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > units_;
  mutable int _units_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Final_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class History : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Final.History) */ {
 public:
  History();
  virtual ~History();

  History(const History& from);

  inline History& operator=(const History& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  History(History&& from) noexcept
    : History() {
    *this = ::std::move(from);
  }

  inline History& operator=(History&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const History& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const History* internal_default_instance() {
    return reinterpret_cast<const History*>(
               &_History_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(History* other);
  friend void swap(History& a, History& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline History* New() const final {
    return CreateMaybeMessage<History>(NULL);
  }

  History* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<History>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const History& from);
  void MergeFrom(const History& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(History* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string oponent = 1;
  void clear_oponent();
  static const int kOponentFieldNumber = 1;
  const ::std::string& oponent() const;
  void set_oponent(const ::std::string& value);
  #if LANG_CXX11
  void set_oponent(::std::string&& value);
  #endif
  void set_oponent(const char* value);
  void set_oponent(const char* value, size_t size);
  ::std::string* mutable_oponent();
  ::std::string* release_oponent();
  void set_allocated_oponent(::std::string* oponent);

  // bool victory = 2;
  void clear_victory();
  static const int kVictoryFieldNumber = 2;
  bool victory() const;
  void set_victory(bool value);

  // @@protoc_insertion_point(class_scope:Final.History)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr oponent_;
  bool victory_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Final_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Users : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Final.Users) */ {
 public:
  Users();
  virtual ~Users();

  Users(const Users& from);

  inline Users& operator=(const Users& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Users(Users&& from) noexcept
    : Users() {
    *this = ::std::move(from);
  }

  inline Users& operator=(Users&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Users& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Users* internal_default_instance() {
    return reinterpret_cast<const Users*>(
               &_Users_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Users* other);
  friend void swap(Users& a, Users& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Users* New() const final {
    return CreateMaybeMessage<Users>(NULL);
  }

  Users* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Users>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Users& from);
  void MergeFrom(const Users& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Users* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Final.Account users = 1;
  int users_size() const;
  void clear_users();
  static const int kUsersFieldNumber = 1;
  ::Final::Account* mutable_users(int index);
  ::google::protobuf::RepeatedPtrField< ::Final::Account >*
      mutable_users();
  const ::Final::Account& users(int index) const;
  ::Final::Account* add_users();
  const ::google::protobuf::RepeatedPtrField< ::Final::Account >&
      users() const;

  // @@protoc_insertion_point(class_scope:Final.Users)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Final::Account > users_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Final_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Account

// int32 id = 1;
inline void Account::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Account::id() const {
  // @@protoc_insertion_point(field_get:Final.Account.id)
  return id_;
}
inline void Account::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Final.Account.id)
}

// string name = 2;
inline void Account::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::name() const {
  // @@protoc_insertion_point(field_get:Final.Account.name)
  return name_.GetNoArena();
}
inline void Account::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Final.Account.name)
}
#if LANG_CXX11
inline void Account::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Final.Account.name)
}
#endif
inline void Account::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Final.Account.name)
}
inline void Account::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Final.Account.name)
}
inline ::std::string* Account::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Final.Account.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_name() {
  // @@protoc_insertion_point(field_release:Final.Account.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Final.Account.name)
}

// string password = 3;
inline void Account::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::password() const {
  // @@protoc_insertion_point(field_get:Final.Account.password)
  return password_.GetNoArena();
}
inline void Account::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Final.Account.password)
}
#if LANG_CXX11
inline void Account::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Final.Account.password)
}
#endif
inline void Account::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Final.Account.password)
}
inline void Account::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Final.Account.password)
}
inline ::std::string* Account::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:Final.Account.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_password() {
  // @@protoc_insertion_point(field_release:Final.Account.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:Final.Account.password)
}

// bool LoggedIn = 4;
inline void Account::clear_loggedin() {
  loggedin_ = false;
}
inline bool Account::loggedin() const {
  // @@protoc_insertion_point(field_get:Final.Account.LoggedIn)
  return loggedin_;
}
inline void Account::set_loggedin(bool value) {
  
  loggedin_ = value;
  // @@protoc_insertion_point(field_set:Final.Account.LoggedIn)
}

// .Final.Player player = 5;
inline bool Account::has_player() const {
  return this != internal_default_instance() && player_ != NULL;
}
inline void Account::clear_player() {
  if (GetArenaNoVirtual() == NULL && player_ != NULL) {
    delete player_;
  }
  player_ = NULL;
}
inline const ::Final::Player& Account::_internal_player() const {
  return *player_;
}
inline const ::Final::Player& Account::player() const {
  const ::Final::Player* p = player_;
  // @@protoc_insertion_point(field_get:Final.Account.player)
  return p != NULL ? *p : *reinterpret_cast<const ::Final::Player*>(
      &::Final::_Player_default_instance_);
}
inline ::Final::Player* Account::release_player() {
  // @@protoc_insertion_point(field_release:Final.Account.player)
  
  ::Final::Player* temp = player_;
  player_ = NULL;
  return temp;
}
inline ::Final::Player* Account::mutable_player() {
  
  if (player_ == NULL) {
    auto* p = CreateMaybeMessage<::Final::Player>(GetArenaNoVirtual());
    player_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Final.Account.player)
  return player_;
}
inline void Account::set_allocated_player(::Final::Player* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_;
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Final.Account.player)
}

// repeated .Final.History gameHist = 6;
inline int Account::gamehist_size() const {
  return gamehist_.size();
}
inline void Account::clear_gamehist() {
  gamehist_.Clear();
}
inline ::Final::History* Account::mutable_gamehist(int index) {
  // @@protoc_insertion_point(field_mutable:Final.Account.gameHist)
  return gamehist_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Final::History >*
Account::mutable_gamehist() {
  // @@protoc_insertion_point(field_mutable_list:Final.Account.gameHist)
  return &gamehist_;
}
inline const ::Final::History& Account::gamehist(int index) const {
  // @@protoc_insertion_point(field_get:Final.Account.gameHist)
  return gamehist_.Get(index);
}
inline ::Final::History* Account::add_gamehist() {
  // @@protoc_insertion_point(field_add:Final.Account.gameHist)
  return gamehist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Final::History >&
Account::gamehist() const {
  // @@protoc_insertion_point(field_list:Final.Account.gameHist)
  return gamehist_;
}

// int32 wins = 7;
inline void Account::clear_wins() {
  wins_ = 0;
}
inline ::google::protobuf::int32 Account::wins() const {
  // @@protoc_insertion_point(field_get:Final.Account.wins)
  return wins_;
}
inline void Account::set_wins(::google::protobuf::int32 value) {
  
  wins_ = value;
  // @@protoc_insertion_point(field_set:Final.Account.wins)
}

// int32 loses = 8;
inline void Account::clear_loses() {
  loses_ = 0;
}
inline ::google::protobuf::int32 Account::loses() const {
  // @@protoc_insertion_point(field_get:Final.Account.loses)
  return loses_;
}
inline void Account::set_loses(::google::protobuf::int32 value) {
  
  loses_ = value;
  // @@protoc_insertion_point(field_set:Final.Account.loses)
}

// bool Challenged = 9;
inline void Account::clear_challenged() {
  challenged_ = false;
}
inline bool Account::challenged() const {
  // @@protoc_insertion_point(field_get:Final.Account.Challenged)
  return challenged_;
}
inline void Account::set_challenged(bool value) {
  
  challenged_ = value;
  // @@protoc_insertion_point(field_set:Final.Account.Challenged)
}

// bool InGame = 10;
inline void Account::clear_ingame() {
  ingame_ = false;
}
inline bool Account::ingame() const {
  // @@protoc_insertion_point(field_get:Final.Account.InGame)
  return ingame_;
}
inline void Account::set_ingame(bool value) {
  
  ingame_ = value;
  // @@protoc_insertion_point(field_set:Final.Account.InGame)
}

// -------------------------------------------------------------------

// Commands

// string command = 1;
inline void Commands::clear_command() {
  command_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Commands::command() const {
  // @@protoc_insertion_point(field_get:Final.Commands.command)
  return command_.GetNoArena();
}
inline void Commands::set_command(const ::std::string& value) {
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Final.Commands.command)
}
#if LANG_CXX11
inline void Commands::set_command(::std::string&& value) {
  
  command_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Final.Commands.command)
}
#endif
inline void Commands::set_command(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Final.Commands.command)
}
inline void Commands::set_command(const char* value, size_t size) {
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Final.Commands.command)
}
inline ::std::string* Commands::mutable_command() {
  
  // @@protoc_insertion_point(field_mutable:Final.Commands.command)
  return command_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Commands::release_command() {
  // @@protoc_insertion_point(field_release:Final.Commands.command)
  
  return command_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Commands::set_allocated_command(::std::string* command) {
  if (command != NULL) {
    
  } else {
    
  }
  command_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), command);
  // @@protoc_insertion_point(field_set_allocated:Final.Commands.command)
}

// string name = 2;
inline void Commands::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Commands::name() const {
  // @@protoc_insertion_point(field_get:Final.Commands.name)
  return name_.GetNoArena();
}
inline void Commands::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Final.Commands.name)
}
#if LANG_CXX11
inline void Commands::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Final.Commands.name)
}
#endif
inline void Commands::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Final.Commands.name)
}
inline void Commands::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Final.Commands.name)
}
inline ::std::string* Commands::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Final.Commands.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Commands::release_name() {
  // @@protoc_insertion_point(field_release:Final.Commands.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Commands::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Final.Commands.name)
}

// string password = 3;
inline void Commands::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Commands::password() const {
  // @@protoc_insertion_point(field_get:Final.Commands.password)
  return password_.GetNoArena();
}
inline void Commands::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Final.Commands.password)
}
#if LANG_CXX11
inline void Commands::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Final.Commands.password)
}
#endif
inline void Commands::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Final.Commands.password)
}
inline void Commands::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Final.Commands.password)
}
inline ::std::string* Commands::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:Final.Commands.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Commands::release_password() {
  // @@protoc_insertion_point(field_release:Final.Commands.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Commands::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:Final.Commands.password)
}

// string message = 4;
inline void Commands::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Commands::message() const {
  // @@protoc_insertion_point(field_get:Final.Commands.message)
  return message_.GetNoArena();
}
inline void Commands::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Final.Commands.message)
}
#if LANG_CXX11
inline void Commands::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Final.Commands.message)
}
#endif
inline void Commands::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Final.Commands.message)
}
inline void Commands::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Final.Commands.message)
}
inline ::std::string* Commands::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:Final.Commands.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Commands::release_message() {
  // @@protoc_insertion_point(field_release:Final.Commands.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Commands::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:Final.Commands.message)
}

// -------------------------------------------------------------------

// Player

// repeated int32 units = 1;
inline int Player::units_size() const {
  return units_.size();
}
inline void Player::clear_units() {
  units_.Clear();
}
inline ::google::protobuf::int32 Player::units(int index) const {
  // @@protoc_insertion_point(field_get:Final.Player.units)
  return units_.Get(index);
}
inline void Player::set_units(int index, ::google::protobuf::int32 value) {
  units_.Set(index, value);
  // @@protoc_insertion_point(field_set:Final.Player.units)
}
inline void Player::add_units(::google::protobuf::int32 value) {
  units_.Add(value);
  // @@protoc_insertion_point(field_add:Final.Player.units)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Player::units() const {
  // @@protoc_insertion_point(field_list:Final.Player.units)
  return units_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Player::mutable_units() {
  // @@protoc_insertion_point(field_mutable_list:Final.Player.units)
  return &units_;
}

// -------------------------------------------------------------------

// History

// string oponent = 1;
inline void History::clear_oponent() {
  oponent_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& History::oponent() const {
  // @@protoc_insertion_point(field_get:Final.History.oponent)
  return oponent_.GetNoArena();
}
inline void History::set_oponent(const ::std::string& value) {
  
  oponent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Final.History.oponent)
}
#if LANG_CXX11
inline void History::set_oponent(::std::string&& value) {
  
  oponent_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Final.History.oponent)
}
#endif
inline void History::set_oponent(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  oponent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Final.History.oponent)
}
inline void History::set_oponent(const char* value, size_t size) {
  
  oponent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Final.History.oponent)
}
inline ::std::string* History::mutable_oponent() {
  
  // @@protoc_insertion_point(field_mutable:Final.History.oponent)
  return oponent_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* History::release_oponent() {
  // @@protoc_insertion_point(field_release:Final.History.oponent)
  
  return oponent_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void History::set_allocated_oponent(::std::string* oponent) {
  if (oponent != NULL) {
    
  } else {
    
  }
  oponent_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oponent);
  // @@protoc_insertion_point(field_set_allocated:Final.History.oponent)
}

// bool victory = 2;
inline void History::clear_victory() {
  victory_ = false;
}
inline bool History::victory() const {
  // @@protoc_insertion_point(field_get:Final.History.victory)
  return victory_;
}
inline void History::set_victory(bool value) {
  
  victory_ = value;
  // @@protoc_insertion_point(field_set:Final.History.victory)
}

// -------------------------------------------------------------------

// Users

// repeated .Final.Account users = 1;
inline int Users::users_size() const {
  return users_.size();
}
inline void Users::clear_users() {
  users_.Clear();
}
inline ::Final::Account* Users::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:Final.Users.users)
  return users_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Final::Account >*
Users::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:Final.Users.users)
  return &users_;
}
inline const ::Final::Account& Users::users(int index) const {
  // @@protoc_insertion_point(field_get:Final.Users.users)
  return users_.Get(index);
}
inline ::Final::Account* Users::add_users() {
  // @@protoc_insertion_point(field_add:Final.Users.users)
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Final::Account >&
Users::users() const {
  // @@protoc_insertion_point(field_list:Final.Users.users)
  return users_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Final

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Final_2eproto
